(("undefined"!=typeof globalThis?globalThis:self).makoChunk_antd=("undefined"!=typeof globalThis?globalThis:self).makoChunk_antd||[]).push([["4bc13e0d"],{"4bc13e0d":function(e,n,t){"use strict";t.d(n,"__esModule",{value:!0}),t.d(n,"texts",{enumerable:!0,get:function(){return a;}}),t("973c6f90");let a=[{value:"Before Ant Design v6, the experience of customizing styles based on open tokens was already great, but there were still some pain points that were difficult to solve. Ant Design v6 made many changes and improvements to address this. Today, let\u2019s talk about how semantic design helps you discover the delicate beauty of components.",paraId:0},{value:"In the past, how did we typically adjust component styles?",paraId:1,tocIndex:0},{value:"Write extensive conditional logic for combinations in ",paraId:2,tocIndex:1},{value:"className",paraId:2,tocIndex:1},{value:" and ",paraId:2,tocIndex:1},{value:"style",paraId:2,tocIndex:1},{value:" attributes",paraId:2,tocIndex:1},{value:"Use numerous props like ",paraId:2,tocIndex:1},{value:"wrapClassName",paraId:2,tocIndex:1},{value:" when modifying styles of different component regions",paraId:2,tocIndex:1},{value:"The code might look like this:",paraId:3,tocIndex:1},{value:"<Button className={variant === 'filled' ? 'btn-filled' : 'btn-outline'}>\n  Submit\n</Button>\n\n<Modal wrapClassName=\"wrap-class\" style={{ backgroundColor: '#fff' }}>\n  Modal\n</Modal>\n\n<Menu style={{ backgroundColor: mode === 'horizontal' ? '#fff' : '#000' }}>\n  <Menu.SubMenu popupClassName=\"popup-class\">\n    <Menu.Item >\n      MenuItem\n    </Menu.Item>\n  </Menu.SubMenu>\n</Menu>\n",paraId:4,tocIndex:1},{value:"Using the theme Design Token design introduced in Ant Design v5:",paraId:5,tocIndex:2},{value:"<ConfigProvider\n  theme={{\n    components: {\n      Notification: {\n        colorTextHeading: token.blue,\n        colorText: token.colorTextSecondary,\n      },\n    },\n  }}\n>\n  {children}\n</ConfigProvider>\n",paraId:6,tocIndex:2},{value:"Apart from these two methods, you might also have written less recommended CSS overrides:",paraId:7,tocIndex:3},{value:".wrapper-class .ant-table {\n  border-radius: 4px;\n  overflow: hidden;\n}\n.wrapper-class .ant-table .ant-table-thead {\n  background-color: #f9fafc;\n  color: #8b97b6;\n}\n",paraId:8,tocIndex:3},{value:"All of the above approaches have various pain points:",paraId:9,tocIndex:3},{value:"Limited available ",paraId:10,tocIndex:3},{value:"props",paraId:10,tocIndex:3},{value:" make it impossible to modify certain regions, and logic is not well-organized",paraId:10,tocIndex:3},{value:"Limited ",paraId:10,tocIndex:3},{value:"Design Token",paraId:10,tocIndex:3},{value:" configuration prevents differentiated styling based on different types/variants",paraId:10,tocIndex:3},{value:"CSS overrides introduce high cognitive load and maintenance costs, with poor maintainability and semantics",paraId:10,tocIndex:3},{value:"To avoid token proliferation and the addition of numerous API props \u2014 which would increase maintenance costs \u2014 these elements were consolidated into a more semantic structure.",paraId:11,tocIndex:4},{value:"The DOM structure has been greatly simplified and refined.",paraId:12,tocIndex:4},{value:"Styles and themes can now be customized more flexibly and in a more maintainable way based on different props.",paraId:12,tocIndex:4},{value:"It\u2019s possible to define styles or class names for specific semantic regions, making it easier to customize local styles or themes.",paraId:12,tocIndex:4},{value:"const classNamesFn: ButtonProps['classNames'] = (info) => {\n  if (info.props.type === 'primary') {\n    return {\n      root: 'demo-btn-root--primary',\n    } satisfies ButtonProps['classNames'];\n  }\n  return {\n    root: 'demo-btn-root--default',\n  } satisfies ButtonProps['classNames'];\n};\n\nconst styles: ButtonProps['styles'] = {\n  root: { borderWidth: 2, borderStyle: 'dashed' },\n  content: { fontStyle: 'italic' },\n  icon: { opacity: 0.85 },\n};\n\nreturn (\n  <Button styles={styles} classNames={classNamesFn}>\n    Button\n  </Button>\n);\n",paraId:13,tocIndex:4},{value:"What's more exciting is that the ",paraId:14,tocIndex:5},{value:"classNames",paraId:14,tocIndex:5},{value:" property integrates perfectly with atomic CSS frameworks like ",paraId:14,tocIndex:5},{value:"Tailwind CSS",paraId:14,tocIndex:5},{value:". This provides developers with unprecedented freedom: you can enjoy the preset behavior and semantic structure of antd components while leveraging Tailwind's utility classes to quickly build any visual style you want. Semantic design + Tailwind CSS, makes component customization extremely flexible.",paraId:14,tocIndex:5},{value:"return (\n  <Button\n    classNames={{\n      root: 'bg-black text-white border-none hover:bg-[#2e2e2e]',\n      icon: 'text-white/90',\n    }}\n    icon={<GiftOutlined />}\n  >\n    Ant Design\n  </Button>\n);\n",paraId:15,tocIndex:5},{value:"Users can give components refined designs for different states based on their preferred color schemes. Let your imagination run wild and make your pages more vibrant and expressive. If you encounter any issues or have better ideas during use, feel free to share feedback \u2014 let\u2019s make Ant Design even better together.",paraId:16,tocIndex:6},{value:"In Ant Design\u2019s design system, tokens are positioned as design variables \u2014 the atomic materials of the design language. Semantic styles, on the other hand, define how those materials are used. They are created by combining design tokens with component-level customizations, allowing for more flexible and expressive styling scenarios. Since semantic styles operate at the component level, they provide better control over styling scope. If you aim to design a fully customized Ant Design theme, the combination of tokens and semantic styling will be your most powerful tool \u2014 together, they enable you to craft a more refined and precisely tailored theme.",paraId:17,tocIndex:7}];}}]);